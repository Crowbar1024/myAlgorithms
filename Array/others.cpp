#include "myheader.h"

// PAT The Best Rank 1012
// 现已知n个考生的3门分数，平均分可以按照这三门算出来。然后分别对这四个分数从高到低排序，
// 这样对每个考生来说有4个排名。
// k个查询，对于每一个学生id，输出当前id学生的最好的排名和它对应的分数，
// 如果名次相同，按照A>C>M>E的顺序输出。如果当前id不存在，输出N/A
// 这道题的难点在于相同分数排名时要跳位，比如 1 1 3
// 下面是核心代码，每次对四门进行排序，和跳位的处理
// for (attr = 0; attr <= 3; attr++) {
//     sort(stu, stu + n, cmp);
//     stu[0].rank[attr] = 1;
//     for (int i = 1; i < n; i++) {
//         if (stu[i - 1].score[attr] > stu[i].score[attr]) {
//             stu[i].rank[attr] = i + 1;
//         }
//         else {
//             stu[i].rank[attr] = stu[i - 1].rank[attr];
//         }
//     }
// }


// 每个考生有两个成绩：GE和GI，最终成绩为(GE + GI) / 2;按照最终成绩排名，如果最终成绩相同，就按照GE排名，
// 如果仍然相同，他们的排名就是相同的。每个申请者有K个选择院校，每个学校也有招生人数限制。
// 按照排名先后，如果当前考生的第一个志愿学校的名额还没满，就录取进去；
// 如果当前志愿名额满了但是该校最后一个录取的人的排名和当前考生相同，则不管招生人数限制，依旧应该被录取；
// 否则考虑该生的下一个志愿。如果所有志愿都没有能被录取，则该生落榜。
// 步骤：
// 1.设立stu结构体，存储学生的id（防止排序后id打乱了顺序），GE和GI的成绩，总评成绩，排名，志愿学校的列表数组。
// 2.设立sch结构体，存储school[i]招生的名额限制maxNum，现在已经招收了的学生个数nowNum，
//     招收的学生的id列表stuID，以及当前已经招收了的学生的排名的最后一名lastRank。
// 3.把学生按照成绩进行排序，并赋值排名。如果GE一样且Grade一样，他们的名次就是一样的。
// 4.从第一个学生开始，根据他的志愿，来尝试被学校录取。如果当前学校名额未满。那么就录取进去，
//     并且让学校的nowNum加1，并且更新lastRank为这个学生的rank。如果当前学校的lastRank等于自己的rank，
//     那么不管名额满不满都录取。而且记得把学生的id添加到学校的stuID列表中。
// 5.输出的时候因为id顺序是乱的，要先从小到大排序，然后输出。每个学校占一行～

